<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Snayer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- remove Material Icons -->
    <!-- add Lucide for modern SVGs -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <!-- Add Inter font from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@700;900&display=swap" rel="stylesheet">
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        background: black;
        font-family: 'Inter', Arial, Helvetica, sans-serif;
        font-weight: 700;
      }
      video::-internal-media-controls-download-button { display:none; }
      video::-webkit-media-controls-enclosure { overflow:hidden; }
      .transition-all { transition: all 0.3s ease-in-out; }
      /* --- Volume slider hover reveal --- */
      .volume-group {
        position: relative;
        display: flex;
        align-items: center;
        transition: width 0.2s;
        width: auto;
        min-width: 2.5rem;
      }
      .volume-group .volume-seekbar-wrapper {
        width: 0;
        opacity: 0;
        pointer-events: none;
        transition: width 0.2s, opacity 0.2s;
      }
      .volume-group.expanded .volume-seekbar-wrapper {
        width: 70px;
        opacity: 1;
        pointer-events: auto;
      }
      .volume-group #time {
        margin-left: 0.5rem;
        transition: margin 0.2s;
      }
      .volume-group.expanded #time {
        margin-left: 6.3rem;
      }
      /* --- Custom Seekbar Styles (from seekbar.html) --- */
      .seekbar-wrapper {
        position: relative;
        width: 100%;
        height: 16px;
        cursor: pointer;
      }
      .seekbar-track {
        background: #2b2b2b;
        border-radius: 999px;
        height: 6px;
        position: absolute;
        width: 100%;
        top: 50%;
        transform: translateY(-50%);
        z-index: 1;
      }
      .seekbar-fill {
        position: absolute;
        height: 6px;
        background: #0099ff;
        border-radius: 999px 0 0 999px;
        top: 50%;
        transform: translateY(-50%);
        z-index: 2;
        transition: width 0.1s linear;
      }
      .seekbar-hover {
        position: absolute;
        height: 6px;
        background: rgba(0, 153, 255, 0.4);
        border-radius: 0 999px 999px 0;
        top: 50%;
        transform: translateY(-50%);
        z-index: 1;
        pointer-events: none;
        display: none;
      }
      .seekbar-thumb {
        position: absolute;
        width: 16px;
        height: 16px;
        background: #0099ff;
        border-radius: 50%;
        box-shadow: 0 0 12px #0099ff;
        top: 50%;
        transform: translate(-50%, -50%);
        z-index: 3;
        transition: left 0.1s linear;
        pointer-events: none;
        user-select: none;
      }
      /* Time indicator tooltip for seekbar */
      #seekbar-time-indicator {
        position: absolute;
        top: -2.2em;
        left: 0;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.85);
        color: #fff;
        font-size: 0.95em;
        padding: 0.18em 0.7em;
        border-radius: 0.5em;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.15s, left 0.1s;
        z-index: 50;
        white-space: nowrap;
      }
      .seekbar-wrapper:hover .seekbar-hover {
        display: block;
      }
      /* --- End Custom Seekbar Styles --- */
      /* Spinner animation and blur */
      #spinner-overlay .spinner-rotate {
        animation: spinner-rotate 1s linear infinite;
        transform-origin: 50% 50%;
      }
      @keyframes spinner-rotate {
        100% { transform: rotate(360deg); }
      }
      /* Only keep .player-title rules not covered by Tailwind */
      .player-title {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 30;
        user-select: none;
        pointer-events: none;
        opacity: 1;
        transition: opacity 0.3s;
      }
      .player-title.hide {
        opacity: 0;
        pointer-events: none;
      }
      @media (max-width: 600px) {
        .player-title {
          font-size: 1.1rem;
          padding: 0.75rem 1rem 0.5rem 1rem;
          width: 100%;
          border-radius: 0;
        }
      }
      /* Remove video::-internal-media-controls-download-button and video::-webkit-media-controls-enclosure (not needed for Tailwind) */
      /* --- Volume Seekbar Styles (match video seekbar) --- */
      .volume-seekbar-wrapper {
        position: absolute;
        left: 2.5rem;
        top: 50%;
        transform: translateY(-50%);
        width: 70px;
        height: 16px;
        cursor: pointer;
        z-index: 30;
        display: flex;
        align-items: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s, width 0.2s;
      }
      .volume-group.expanded .volume-seekbar-wrapper {
        opacity: 1;
        pointer-events: auto;
      }
      .volume-seekbar-track {
        background: #2b2b2b;
        border-radius: 999px;
        height: 6px;
        width: 100%;
        position: absolute;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        z-index: 1;
      }
      .volume-seekbar-fill {
        position: absolute;
        height: 6px;
        background: #0099ff;
        border-radius: 999px 0 0 999px;
        top: 50%;
        left: 0;
        transform: translateY(-50%);
        z-index: 2;
        transition: width 0.1s linear;
      }
      .volume-seekbar-thumb {
        position: absolute;
        width: 14px;
        height: 14px;
        background: #0099ff;
        border-radius: 50%;
        box-shadow: 0 0 8px #0099ff;
        top: 50%;
        transform: translate(-50%, -50%);
        z-index: 3;
        transition: left 0.1s linear;
      }
      /* Hide the old input slider visually */
      .volume-slider { display: none !important; }
      /* --- End Volume Seekbar Styles --- */
    </style>
  </head>
  <body class="w-full h-full">
    <div id="player-container" class="absolute inset-0 w-full h-full">
      <!-- Player Title -->
      <div class="player-title w-full bg-gradient-to-b from-black/90 via-black/60 to-transparent px-6 py-3 text-white font-black text-xl select-none pointer-events-none transition-opacity duration-300 absolute top-0 left-0 z-30" id="player-title">
        undefined
      </div>
      <!-- Spinner overlay -->
      <div id="spinner-overlay" style="display:none; position:absolute; inset:0; z-index:20; background:rgba(0,0,0,0.15); pointer-events:none;">
        <div style="position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);">
          <svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <filter id="blur" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="4" />
              </filter>
            </defs>
            <g filter="url(#blur)" class="spinner-rotate">
              <circle cx="50" cy="50" r="30" fill="none" stroke="black" stroke-width="6" stroke-linecap="round" stroke-dasharray="200" stroke-dashoffset="80" />
            </g>
            <g class="spinner-rotate">
              <circle cx="50" cy="50" r="30" fill="none" stroke="#ffffff" stroke-width="6" stroke-linecap="round" stroke-dasharray="200" stroke-dashoffset="80" />
            </g>
          </svg>
        </div>
      </div>

      <video id="video" class="w-full h-full object-contain" preload="metadata"></video>
      <div id="controls" class="absolute bottom-0 w-full bg-gradient-to-t from-black via-black/40 to-transparent p-4 space-y-3 transition-all duration-300 ease-in-out">
        <!-- Custom Seekbar (replaces old input range) -->
        <div class="seekbar-wrapper" id="seekbar">
          <div class="seekbar-track"></div>
          <div class="seekbar-fill" id="fill"></div>
          <div class="seekbar-hover" id="hoverFill"></div>
          <div class="seekbar-thumb" id="thumb"></div>
        </div>

        <div class="flex items-center justify-between text-white">
          <div class="flex items-center space-x-3 volume-flex-group">
            <!-- play/pause -->
            <button id="play-pause" class="text-white hover:text-[#0099ff] transition-all">
              <i data-lucide="play" class="lucide w-6 h-6"></i>
            </button>
            <!-- backward 10s -->
            <button id="backward-10" class="text-white hover:text-[#0099ff] transition-all">
              <i data-lucide="rotate-ccw" class="lucide w-6 h-6"></i>
            </button>
            <!-- forward 10s -->
            <button id="forward-10" class="text-white hover:text-[#0099ff] transition-all">
              <i data-lucide="rotate-cw" class="lucide w-6 h-6"></i>
            </button>

            <!-- mute/volume + time in a flex row -->
            <div class="flex items-center relative group volume-group transition-all duration-200" style="overflow:visible;">
              <div id="volume-hover-area" class="absolute left-0 top-1/2 -translate-y-1/2 h-8 w-8 z-0 transition-all duration-200" style="background:transparent;"></div>
              <button id="mute" class="text-white hover:text-[#0099ff] transition-all relative z-10">
                <i data-lucide="volume-2" class="lucide w-6 h-6"></i>
              </button>
              <!-- Custom Volume Seekbar -->
              <div class="volume-seekbar-wrapper transition-all duration-200" id="volumeSeekbar">
                <div class="volume-seekbar-track"></div>
                <div class="volume-seekbar-fill" id="volumeFill"></div>
                <div class="volume-seekbar-thumb" id="volumeThumb"></div>
              </div>
              <input id="volume" type="range" min="0" max="1" step="0.01" value="1"
                     class="volume-slider w-16 h-1 accent-[#0099ff] absolute left-full ml-2 opacity-0 pointer-events-none transition-all duration-200 z-20" />
              <span id="time" class="text-sm ml-2 whitespace-nowrap">0:00 / 0:00</span>
            </div>
          </div>

          <div class="flex items-center space-x-3">
            <!-- subtitles  -->
            <button class="text-white hover:text-[#0099ff] transition-all relative group">
              <i data-lucide="message-square" class="lucide w-6 h-6"></i>
              <div class="absolute bottom-full right-1/2 translate-x-1/2 mb-2 w-40 bg-black/80 backdrop-blur-sm
                          rounded-md shadow-lg p-2 text-sm text-left opacity-0 invisible
                          group-hover:opacity-100 group-hover:visible transition-all duration-200">
                <p class="font-semibold mb-1 px-2">Subtitles</p>
                <a class="block px-2 py-1 hover:bg-white/10 rounded" href="#">Off</a>
                <a class="block px-2 py-1 hover:bg-white/10 rounded bg-white/10 text-[#0099ff]" href="#">English</a>
                <a class="block px-2 py-1 hover:bg-white/10 rounded" href="#">Español</a>
              </div>
            </button>

            <!-- settings -->
            <button class="text-white hover:text-[#0099ff] transition-all">
              <i data-lucide="settings" class="lucide w-6 h-6"></i>
            </button>

            <!-- fullscreen -->
            <button id="fullscreen" class="text-white hover:text-[#0099ff] transition-all">
              <i data-lucide="maximize" class="lucide w-6 h-6"></i>
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      // create all Lucide icons
      lucide.createIcons();
      // Set player title from injected variable if present
      document.addEventListener('DOMContentLoaded', function() {
        var playerTitle = window.__PLAYER_TITLE__ || 'undefined';
        var titleDiv = document.getElementById('player-title');
        if (titleDiv) titleDiv.textContent = playerTitle;
      });

      const video = document.getElementById("video");
      const playPauseBtn = document.getElementById("play-pause");
      const muteBtn = document.getElementById("mute");
      const volumeSlider = document.getElementById("volume");
      const seekbar = document.getElementById("seekbar");
      const timeLabel = document.getElementById("time");
      const fullscreenBtn = document.getElementById("fullscreen");
      const backward10Btn = document.getElementById("backward-10");
      const forward10Btn = document.getElementById("forward-10");
      const spinnerOverlay = document.getElementById("spinner-overlay");

      // --- General video source selection for MP4 and HLS ---
      (async () => {
        let source = window.source;
        if (!source) {
          try {
            const config = await fetch('/config').then(r => r.json());
            source = config.source;
          } catch {}
        }
        if (!source) return;
  const isM3U8 = source.endsWith('.m3u8') || /[?&]m3u8=1(?:&|$)/.test(source);
        function setVideoSource(url) {
          while (video.firstChild) video.removeChild(video.firstChild);
          video.removeAttribute('src');
          if (isM3U8) {
            if (video.canPlayType('application/vnd.apple.mpegurl')) {
              video.src = url;
            } else if (window.Hls) {
              const hls = new Hls();
              hls.loadSource(url);
              hls.attachMedia(video);
            } else {
              video.outerHTML = '<div class="text-white p-8">Your browser does not support HLS playback.</div>';
            }
          } else {
            const sourceEl = document.createElement('source');
            sourceEl.src = url;
            sourceEl.type = 'video/mp4';
            video.appendChild(sourceEl);
            video.load();
          }
          seekbar.value = 0;
        }
        setVideoSource(source);
        // Autoplay when source is set
        //video.muted = true;
        video.play().catch(() => {});
      })();

      function formatTime(t) {
        if (!isFinite(t) || t < 0) return '0:00';
        const h = Math.floor(t / 3600);
        const m = Math.floor((t % 3600) / 60);
        const s = Math.floor(t % 60).toString().padStart(2, '0');
        if (h > 0) {
          return `${h}:${m.toString().padStart(2, '0')}:${s}`;
        } else {
          return `${m}:${s}`;
        }
      }

      function updateIcons() {
        // swap play/pause icon
        playPauseBtn.innerHTML = `<i data-lucide="${video.paused ? 'play' : 'pause'}" class="lucide w-6 h-6"></i>`;
        // swap volume icon
        muteBtn.innerHTML = `<i data-lucide="${video.muted || video.volume===0 ? 'volume-x' : 'volume-2'}" class="lucide w-6 h-6"></i>`;
        // Do NOT update fullscreen icon here
        lucide.createIcons();
      }

      // fullscreen toggle (make only the player-container fullscreen)
      fullscreenBtn.addEventListener("click", () => {
        const playerContainer = document.getElementById("player-container");
        if (!document.fullscreenElement) {
          playerContainer.requestFullscreen().catch(console.error);
        } else {
          document.exitFullscreen();
        }
      });

      // Listen for fullscreen change and update the icon accordingly
      ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'].forEach(eventType => {
        document.addEventListener(eventType, () => {
          fullscreenBtn.innerHTML = `<i data-lucide=\"${document.fullscreenElement ? 'minimize' : 'maximize'}\" class=\"lucide w-6 h-6\"></i>`;
          lucide.createIcons();
        });
      });

      // 1. play/pause on button
      playPauseBtn.addEventListener("click", () => {
        video.paused ? video.play() : video.pause();
        updateIcons();
      });

      // 1b. play/pause on video click
      video.addEventListener("click", () => {
        video.paused ? video.play() : video.pause();
        updateIcons();
      });

      // mute toggle
      muteBtn.addEventListener("click", () => {
        video.muted = !video.muted;
        updateIcons();
      });

      // volume slider
      volumeSlider.addEventListener("input", () => {
        video.volume = volumeSlider.value;
        video.muted = video.volume === 0;
        updateIcons();
      });
      // keep volume slider in sync with video volume
      video.addEventListener("volumechange", () => {
        volumeSlider.value = video.volume;
        updateIcons();
      });

      // seekbar & time
      video.addEventListener("timeupdate", () => {
        if (!isNaN(video.duration) && video.duration > 0) {
          seekbar.value = (video.currentTime / video.duration) * 100;
        } else {
          seekbar.value = 0;
        }
        timeLabel.textContent = `${formatTime(video.currentTime)} / ${formatTime(video.duration)}`;
      });
      seekbar.addEventListener("input", () => {
        if (!isNaN(video.duration) && video.duration > 0) {
          video.currentTime = (seekbar.value / 100) * video.duration;
        }
      });

      // backward 10s
      backward10Btn.addEventListener("click", () => {
        video.currentTime = Math.max(0, video.currentTime - 10);
      });
      // forward 10s
      forward10Btn.addEventListener("click", () => {
        if (!isNaN(video.duration)) {
          video.currentTime = Math.min(video.duration, video.currentTime + 10);
        }
      });

      // Keyboard controls
      window.addEventListener("keydown", (e) => {
        // Ignore if focused on input/textarea
        if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) return;
        switch (e.key) {
          case 'f':
          case 'F':
            fullscreenBtn.click();
            e.preventDefault();
            break;
          case ' ': // spacebar for play/pause
            video.paused ? video.play() : video.pause();
            updateIcons();
            e.preventDefault();
            break;
          case 'ArrowLeft':
            backward10Btn.click();
            e.preventDefault();
            break;
          case 'ArrowRight':
            forward10Btn.click();
            e.preventDefault();
            break;
          case 'ArrowUp':
            video.volume = Math.min(1, video.volume + 0.05);
            video.muted = false;
            // volumechange event will sync slider and icons
            e.preventDefault();
            break;
          case 'ArrowDown':
            video.volume = Math.max(0, video.volume - 0.05);
            video.muted = video.volume === 0;
            // volumechange event will sync slider and icons
            e.preventDefault();
            break;
        }
      });

      // --- Improved volume slider hover logic ---
      const volumeGroup = document.querySelector('.volume-group');
      const volumeHoverArea = document.getElementById('volume-hover-area');
      // Remove old logic
      // New logic: expand hover area and show slider if mouse is over area
      let hoverTimeout;
      function expandVolumeArea(expand) {
        if (expand) {
          volumeGroup.classList.add('expanded');
        } else {
          volumeGroup.classList.remove('expanded');
        }
      }
      // When mouse enters the hover area, expand and show slider
      volumeHoverArea.addEventListener('mouseenter', () => {
        expandVolumeArea(true);
        clearTimeout(hoverTimeout);
      });
      // When mouse leaves the hover area, start a short timeout before hiding
      volumeHoverArea.addEventListener('mouseleave', () => {
        hoverTimeout = setTimeout(() => expandVolumeArea(false), 120);
      });
      // If mouse enters mute, slider, or seekbar, keep expanded
      muteBtn.addEventListener('mouseenter', () => {
        expandVolumeArea(true);
        clearTimeout(hoverTimeout);
      });
      volumeSlider.addEventListener('mouseenter', () => {
        expandVolumeArea(true);
        clearTimeout(hoverTimeout);
      });
      document.getElementById('volumeSeekbar').addEventListener('mouseenter', () => {
        expandVolumeArea(true);
        clearTimeout(hoverTimeout);
      });
      // If mouse leaves mute, slider, or seekbar, start a short timeout before hiding
      muteBtn.addEventListener('mouseleave', () => {
        hoverTimeout = setTimeout(() => expandVolumeArea(false), 120);
      });
      volumeSlider.addEventListener('mouseleave', () => {
        hoverTimeout = setTimeout(() => expandVolumeArea(false), 120);
      });
      document.getElementById('volumeSeekbar').addEventListener('mouseleave', () => {
        hoverTimeout = setTimeout(() => expandVolumeArea(false), 120);
      });

      // --- Custom Seekbar Logic (from seekbar.html, adapted for video) ---
      const seekbarWrapper = document.getElementById('seekbar');
      const fill = document.getElementById('fill');
      const thumb = document.getElementById('thumb');
      const hoverFill = document.getElementById('hoverFill');
      // Time indicator tooltip
      let seekbarTimeIndicator = document.getElementById('seekbar-time-indicator');
      if (!seekbarTimeIndicator) {
        seekbarTimeIndicator = document.createElement('div');
        seekbarTimeIndicator.id = 'seekbar-time-indicator';
        seekbarWrapper.appendChild(seekbarTimeIndicator);
      }

      function updateSeekbarUI() {
        if (!isNaN(video.duration) && video.duration > 0) {
          const progress = video.currentTime / video.duration;
          const width = seekbarWrapper.offsetWidth;
          const px = width * progress;
          fill.style.width = `${px}px`;
          thumb.style.left = `${px}px`;
        } else {
          fill.style.width = `0px`;
          thumb.style.left = `0px`;
        }
      }

      // Sync seekbar with video time
      video.addEventListener('timeupdate', updateSeekbarUI);
      video.addEventListener('loadedmetadata', updateSeekbarUI);
      window.addEventListener('resize', updateSeekbarUI);

      // Seek on click/drag (only horizontal, thumb is not interactive)
      let isSeeking = false;
      function seekToMouse(e) {
        const rect = seekbarWrapper.getBoundingClientRect();
        const mouseX = e.touches ? e.touches[0].clientX - rect.left : e.clientX - rect.left;
        const ratio = Math.max(0, Math.min(1, mouseX / seekbarWrapper.offsetWidth));
        if (!isNaN(video.duration) && video.duration > 0) {
          video.currentTime = ratio * video.duration;
        }
      }
      seekbarWrapper.addEventListener('mousedown', (e) => {
        if (e.target === thumb) return; // Prevent direct thumb drag
        isSeeking = true;
        seekToMouse(e);
      });
      window.addEventListener('mousemove', (e) => {
        if (isSeeking) seekToMouse(e);
      });
      window.addEventListener('mouseup', () => {
        isSeeking = false;
      });
      // Touch support
      seekbarWrapper.addEventListener('touchstart', (e) => {
        isSeeking = true;
        seekToMouse(e);
      });
      window.addEventListener('touchmove', (e) => {
        if (isSeeking) seekToMouse(e);
      });
      window.addEventListener('touchend', () => {
        isSeeking = false;
      });

      // Hover fill effect & time indicator
      seekbarWrapper.addEventListener('mousemove', (e) => {
        const rect = seekbarWrapper.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const totalWidth = seekbarWrapper.offsetWidth;
        const progress = !isNaN(video.duration) && video.duration > 0 ? video.currentTime / video.duration : 0;
        const currentX = totalWidth * progress;
        const isRight = mouseX > currentX;
        if (isRight) {
          hoverFill.style.left = `${currentX}px`;
          hoverFill.style.width = `${mouseX - currentX}px`;
        } else {
          hoverFill.style.left = `${mouseX}px`;
          hoverFill.style.width = `${currentX - mouseX}px`;
        }
        // Time indicator
        if (!isNaN(video.duration) && video.duration > 0) {
          const hoverRatio = Math.max(0, Math.min(1, mouseX / totalWidth));
          const hoverTime = hoverRatio * video.duration;
          seekbarTimeIndicator.textContent = formatTime(hoverTime);
          seekbarTimeIndicator.style.left = `${mouseX}px`;
          seekbarTimeIndicator.style.opacity = '1';
        } else {
          seekbarTimeIndicator.style.opacity = '0';
        }
      });
      seekbarWrapper.addEventListener('mouseleave', () => {
        hoverFill.style.width = `0px`;
        seekbarTimeIndicator.style.opacity = '0';
      });
      // --- End Custom Seekbar Logic ---


      // init
      video.addEventListener("loadedmetadata", () => {
        timeLabel.textContent = `0:00 / ${formatTime(video.duration)}`;
        updateIcons();
      });

      // --- Spinner show/hide on buffering ---
      function showSpinner(show) {
        spinnerOverlay.style.display = show ? 'block' : 'none';
      }
      video.addEventListener('waiting', () => showSpinner(true));
      video.addEventListener('playing', () => showSpinner(false));
      video.addEventListener('canplay', () => showSpinner(false));
      video.addEventListener('canplaythrough', () => showSpinner(false));
      video.addEventListener('seeking', () => showSpinner(true));
      video.addEventListener('seeked', () => showSpinner(false));

      // --- Controls & Mouse Hide Logic ---
      const controls = document.getElementById('controls');
      const playerContainer = document.getElementById('player-container');
      let hideTimeout;
      function showControlsAndCursor() {
        controls.style.opacity = '1';
        controls.style.pointerEvents = '';
        playerContainer.style.cursor = '';
        document.querySelector('.player-title').classList.remove('hide');
      }
      function hideControlsAndCursor() {
        controls.style.opacity = '0';
        controls.style.pointerEvents = 'none';
        playerContainer.style.cursor = 'none';
        document.querySelector('.player-title').classList.add('hide');
      }
      function scheduleHide() {
        clearTimeout(hideTimeout);
        hideTimeout = setTimeout(() => {
          hideControlsAndCursor();
        }, 3000);
      }
      // Show controls/cursor on mouse move, then schedule hide
      playerContainer.addEventListener('mousemove', () => {
        showControlsAndCursor();
        scheduleHide();
      });
      // Hide immediately when mouse leaves video area
      playerContainer.addEventListener('mouseleave', () => {
        clearTimeout(hideTimeout);
        hideControlsAndCursor();
      });
      // Show controls/cursor when mouse enters video area
      playerContainer.addEventListener('mouseenter', () => {
        showControlsAndCursor();
        scheduleHide();
      });
      // Initially show controls
      showControlsAndCursor();
      // Prevent controls from hiding if mouse is over controls
      controls.addEventListener('mouseenter', () => {
        clearTimeout(hideTimeout);
        showControlsAndCursor();
      });
      controls.addEventListener('mouseleave', () => {
        scheduleHide();
      });

      // --- Custom Volume Seekbar Logic ---
      const volumeSeekbar = document.getElementById('volumeSeekbar');
      const volumeFill = document.getElementById('volumeFill');
      const volumeThumb = document.getElementById('volumeThumb');
      // Update volume seekbar UI
      function updateVolumeSeekbarUI() {
        // Always use the full seekbar width (70px) for calculation
        const width = 70;
        const px = width * video.volume;
        volumeFill.style.width = `${px}px`;
        volumeThumb.style.left = `${px}px`;
      }
      // Set initial volume to max (1) on load and update thumb position
      video.volume = 1;
      // Ensure thumb is correct on DOMContentLoaded and after layout
      window.addEventListener('DOMContentLoaded', () => {
        updateVolumeSeekbarUI();
        setTimeout(updateVolumeSeekbarUI, 0);
      });
      // Sync custom seekbar with video volume
      video.addEventListener('volumechange', updateVolumeSeekbarUI);
      window.addEventListener('resize', updateVolumeSeekbarUI);
      // Seek on click/drag
      let isVolumeSeeking = false;
      function setVolumeFromMouse(e) {
        const rect = volumeSeekbar.getBoundingClientRect();
        const mouseX = e.touches ? e.touches[0].clientX - rect.left : e.clientX - rect.left;
        const ratio = Math.max(0, Math.min(1, mouseX / volumeSeekbar.offsetWidth));
        video.volume = ratio;
        video.muted = ratio === 0;
      }
      volumeSeekbar.addEventListener('mousedown', (e) => {
        isVolumeSeeking = true;
        setVolumeFromMouse(e);
      });
      window.addEventListener('mousemove', (e) => {
        if (isVolumeSeeking) setVolumeFromMouse(e);
      });
      window.addEventListener('mouseup', () => {
        isVolumeSeeking = false;
      });
      // Touch support
      volumeSeekbar.addEventListener('touchstart', (e) => {
        isVolumeSeeking = true;
        setVolumeFromMouse(e);
      });
      window.addEventListener('touchmove', (e) => {
        if (isVolumeSeeking) setVolumeFromMouse(e);
      });
      window.addEventListener('touchend', () => {
        isVolumeSeeking = false;
      });
      // Init
      updateVolumeSeekbarUI();
      // --- End Custom Volume Seekbar Logic ---

      // --- Subtitle Logic ---
      let subtitleList = Array.isArray(window.__SUBTITLES__) ? window.__SUBTITLES__ : [];
      let currentSubtitle = null;
      let subtitleCues = [];
      let subtitleDisplay = document.createElement('div');
      subtitleDisplay.style.position = 'absolute';
      subtitleDisplay.style.left = '50%';
      subtitleDisplay.style.bottom = '12%';
      subtitleDisplay.style.transform = 'translateX(-50%)';
      subtitleDisplay.style.color = '#fff';
      subtitleDisplay.style.fontSize = '1.5em';
      subtitleDisplay.style.textShadow = '0 2px 8px #000, 0 0 2px #000';
      subtitleDisplay.style.textAlign = 'center';
      subtitleDisplay.style.pointerEvents = 'none';
      subtitleDisplay.style.zIndex = '40';
      subtitleDisplay.id = 'subtitle-display';
      // Blurred background for subtitles
      subtitleDisplay.style.background = 'rgba(0,0,0,0.35)';
      subtitleDisplay.style.backdropFilter = 'blur(6px)';
      subtitleDisplay.style.borderRadius = '0.5em';
      subtitleDisplay.style.padding = '0.2em 1em';
      subtitleDisplay.style.minWidth = '0';
      subtitleDisplay.style.minHeight = '0';
      subtitleDisplay.style.maxWidth = '96vw';
      subtitleDisplay.style.wordBreak = 'break-word';
      // Responsive font size for mobile
      function updateSubtitleFontSize() {
        const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
        const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
        // Consider phone if width <= 900px
        const isPhone = vw <= 900;
        const isLandscape = vw > vh;
        if (isPhone && isLandscape) {
          // Landscape on phone: make subtitles even smaller
          subtitleDisplay.style.fontSize = '0.7em';
          subtitleDisplay.style.padding = '0.08em 0.2em';
          subtitleDisplay.style.maxWidth = '90vw';
        } else if (vw <= 400) {
          subtitleDisplay.style.fontSize = '0.85em';
          subtitleDisplay.style.padding = '0.1em 0.3em';
          subtitleDisplay.style.maxWidth = '96vw';
        } else if (vw <= 600) {
          subtitleDisplay.style.fontSize = '1em';
          subtitleDisplay.style.padding = '0.15em 0.5em';
          subtitleDisplay.style.maxWidth = '96vw';
        } else {
          subtitleDisplay.style.fontSize = '1.5em';
          subtitleDisplay.style.padding = '0.2em 1em';
          subtitleDisplay.style.maxWidth = '96vw';
        }
      }
      window.addEventListener('resize', updateSubtitleFontSize);
      updateSubtitleFontSize();
      document.getElementById('player-container').appendChild(subtitleDisplay);

      // Helper: Parse SRT to cues (no regex literals)
      function parseSRT(srt) {
        // Split by double newlines, then parse each block
        var blocks = srt.replace(/\r/g, '').split(/\n\n+/);
        var cues = [];
        for (var i = 0; i < blocks.length; i++) {
          var lines = blocks[i].split('\n');
          if (lines.length >= 2) {
            var timeLine = lines[1];
            var timeMatch = timeLine && timeLine.indexOf('-->') !== -1 ? timeLine.split('-->') : null;
            if (timeMatch && timeMatch.length === 2) {
              var start = toSeconds(timeMatch[0].trim());
              var end = toSeconds(timeMatch[1].trim());
              // Fix weird emoji/encoding: decode as UTF-8 and normalize
              var text = lines.slice(2).join('<br>');
              try { text = decodeURIComponent(escape(text)).normalize('NFC'); } catch(e) {}
              cues.push({ start: start, end: end, text: text });
            }
          }
        }
        return cues;
      }
      function toSeconds(time) {
        // 00:00:01,000 or 00:00:01.000
        var t = time.replace(',', '.').split(':');
        var s = t[2] ? t[2].split('.') : ['0', '0'];
        var h = parseInt(t[0], 10) || 0;
        var m = parseInt(t[1], 10) || 0;
        var sec = parseInt(s[0], 10) || 0;
        var ms = parseInt(s[1], 10) || 0;
        return h * 3600 + m * 60 + sec + ms / 1000;
      }

      // Render subtitle menu (no compression, just first subtitle per language)
      let subtitleMenuOpen = false;
      let subtitleMenuBtn = null;
      let subtitleMenuDiv = null;
      function renderSubtitleMenu() {
        // Replace icon to 'captions' (lucide)
        const oldBtn = document.querySelector('.group .lucide-message-square');
        if (oldBtn) {
          oldBtn.setAttribute('data-lucide', 'captions');
          oldBtn.classList.remove('lucide-message-square');
          oldBtn.classList.add('lucide-captions');
          lucide.createIcons();
        }
        // Find the button and menu
        subtitleMenuBtn = document.querySelector('.group .lucide-captions').parentElement;
        subtitleMenuDiv = subtitleMenuBtn.querySelector('div');
        // Make menu fixed height, scrollable, and hidden by default
        subtitleMenuDiv.style.maxHeight = '220px';
        subtitleMenuDiv.style.overflowY = 'auto';
        subtitleMenuDiv.style.background = 'rgba(0,0,0,0.85)';
        subtitleMenuDiv.style.backdropFilter = 'blur(8px)';
        subtitleMenuDiv.style.borderRadius = '0.5em';
        subtitleMenuDiv.style.boxShadow = '0 4px 24px #0008';
        subtitleMenuDiv.style.display = 'none';
        subtitleMenuDiv.style.position = 'absolute';
        subtitleMenuDiv.style.zIndex = '100';
        // Render menu content
        subtitleMenuDiv.innerHTML = '<p class="font-semibold mb-1 px-2 text-white">Subtitles</p><hr style="border:0;border-top:1px solid #fff;margin:0 0 4px 0;">';
        var off = document.createElement('a');
        off.className = 'block px-2 py-1 hover:bg-white/10 rounded flex items-center justify-between';
        off.href = '#';
        off.textContent = 'Off';
        if (!currentSubtitle) {
          off.innerHTML = '<span>Off</span><i data-lucide="check" class="lucide w-4 h-4 ml-1 align-middle" style="color:#0099ff;"></i>';
        }
        off.onclick = function(e) { e.preventDefault(); selectSubtitle(null, true); closeSubtitleMenu(); renderSubtitleMenu(); };
        subtitleMenuDiv.appendChild(off);
        // Only take the first subtitle for each language
        const seenLangs = {};
        subtitleList.forEach(function(sub, i) {
          const lang = (sub.label || sub.display || sub.language || sub.format || '').toLowerCase();
          if (seenLangs[lang]) return;
          seenLangs[lang] = true;
          var a = document.createElement('a');
          a.className = 'block px-2 py-1 hover:bg-white/10 rounded flex items-center justify-between';
          a.href = '#';
          a.textContent = sub.label || sub.display || sub.language || sub.format || ('Subtitle ' + (i+1));
          // Show tick if this is the current subtitle
          if (currentSubtitle && (currentSubtitle === sub || (currentSubtitle.file === sub.file && currentSubtitle.url === sub.url))) {
            a.innerHTML = '<span style="color:white;">' + (sub.label || sub.display || sub.language || sub.format || ('Subtitle ' + (i+1))) + '</span><i data-lucide="check" class="lucide w-4 h-4 ml-1 align-middle" style="color:#0099ff;"></i>';
          } else {
            a.innerHTML = '<span style="color:white;">' + (sub.label || sub.display || sub.language || sub.format || ('Subtitle ' + (i+1))) + '</span>';
          }
          a.onclick = function(e) { e.preventDefault(); selectSubtitle(sub, true); closeSubtitleMenu(); renderSubtitleMenu(); };
          subtitleMenuDiv.appendChild(a);
        });
        lucide.createIcons();
      }
      function openSubtitleMenu() {
        if (!subtitleMenuDiv) return;
        subtitleMenuDiv.style.display = 'block';
        subtitleMenuOpen = true;
      }
      function closeSubtitleMenu() {
        if (!subtitleMenuDiv) return;
        subtitleMenuDiv.style.display = 'none';
        subtitleMenuOpen = false;
      }
      // Toggle menu on click
      document.addEventListener('DOMContentLoaded', function() {
        renderSubtitleMenu();
        if (subtitleMenuBtn) {
          subtitleMenuBtn.onclick = function(e) {
            e.preventDefault();
            if (subtitleMenuOpen) {
              closeSubtitleMenu();
            } else {
              openSubtitleMenu();
            }
          };
        }
      });
      // Close menu if controls disappear or click outside
      controls.addEventListener('mouseleave', closeSubtitleMenu);
      document.addEventListener('click', function(e) {
        if (subtitleMenuOpen && subtitleMenuDiv && !subtitleMenuDiv.contains(e.target) && !subtitleMenuBtn.contains(e.target)) {
          closeSubtitleMenu();
        }
      });
      // Also close on hideControlsAndCursor
      const origHideControls = hideControlsAndCursor;
      hideControlsAndCursor = function() {
        closeSubtitleMenu();
        origHideControls();
      };
      function selectSubtitle(sub, forceImmediateIcon) {
        currentSubtitle = sub;
        subtitleCues = [];
        subtitleDisplay.innerHTML = '';
        if (!sub) { if (forceImmediateIcon) renderSubtitleMenu(); return; }
        var url = sub.file || sub.url;
        if (!url) { if (forceImmediateIcon) renderSubtitleMenu(); return; }
        fetch(url).then(function(r) { return r.text(); }).then(function(srt) {
          subtitleCues = parseSRT(srt);
          if (forceImmediateIcon) renderSubtitleMenu();
        });
      }
      // Show subtitle for current time
      video.addEventListener('timeupdate', function() {
        if (!subtitleCues.length) {
          subtitleDisplay.innerHTML = '';
          subtitleDisplay.style.background = 'none';
          subtitleDisplay.style.backdropFilter = 'none';
          subtitleDisplay.style.borderRadius = '0';
          subtitleDisplay.style.padding = '0';
          return;
        }
        var t = video.currentTime;
        var cue = null;
        for (var i = 0; i < subtitleCues.length; i++) {
          if (t >= subtitleCues[i].start && t <= subtitleCues[i].end) {
            cue = subtitleCues[i];
            break;
          }
        }
        if (cue && cue.text && cue.text.trim() !== '') {
          subtitleDisplay.innerHTML = cue.text;
          subtitleDisplay.style.background = 'rgba(0,0,0,0.35)';
          subtitleDisplay.style.backdropFilter = 'blur(6px)';
          subtitleDisplay.style.borderRadius = '0.5em';
          subtitleDisplay.style.padding = '0.2em 1em';
        } else {
          subtitleDisplay.innerHTML = '';
          subtitleDisplay.style.background = 'none';
          subtitleDisplay.style.backdropFilter = 'none';
          subtitleDisplay.style.borderRadius = '0';
          subtitleDisplay.style.padding = '0';
        }
      });
    </script>
    <style>
      /* Seek overlay for swipe/double-tap feedback */
      #seek-overlay {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        z-index: 50;
        background: rgba(0,0,0,0.7);
        color: #fff;
        font-size: 2rem;
        font-weight: bold;
        padding: 0.7em 1.5em;
        border-radius: 1.5em;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
        user-select: none;
        min-width: 120px;
        text-align: center;
      }
      /* Subtitle overlay responsive styles */
      #subtitle-display {
        font-size: 1.5em;
        padding: 0.2em 1em;
      }
      @media (max-width: 600px) {
        #subtitle-display {
          font-size: 1em !important;
          padding: 0.15em 0.5em !important;
          max-width: 96vw;
          line-height: 1.2;
        }
      }
      @media (max-width: 400px) {
        #subtitle-display {
          font-size: 0.85em !important;
          padding: 0.1em 0.3em !important;
        }
      }
    </style>
    <div id="seek-overlay"></div>
    <script>
      // --- Touch/Swipe/Double-tap Seek Logic ---
      function isTouchDevice() {
        return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      }
      if (isTouchDevice()) {
        const playerContainer = document.getElementById('player-container');
        const seekOverlay = document.getElementById('seek-overlay');
        let touchStartX = 0, touchStartY = 0, lastSeek = 0, seeking = false, seekTimeout;
        let lastTap = 0, tapX = 0;
        // --- Helper: ensure overlay is visible in fullscreen ---
        function updateSeekOverlayParent() {
          // Always append to the fullscreen element if in fullscreen, else to body
          const fsElem = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
          if (fsElem && !fsElem.contains(seekOverlay)) {
            fsElem.appendChild(seekOverlay);
          } else if (!fsElem && seekOverlay.parentElement !== document.body) {
            document.body.appendChild(seekOverlay);
          }
        }
        // Listen for fullscreen changes
        ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'].forEach(eventType => {
          document.addEventListener(eventType, updateSeekOverlayParent);
        });
        // Initial placement
        updateSeekOverlayParent();
        // --- Swipe to seek ---
        playerContainer.addEventListener('touchstart', function(e) {
          updateSeekOverlayParent();
          if (e.touches.length === 1) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            lastSeek = 0;
            seeking = false;
          }
        });
        playerContainer.addEventListener('touchmove', function(e) {
          if (e.touches.length === 1) {
            const dx = e.touches[0].clientX - touchStartX;
            const dy = e.touches[0].clientY - touchStartY;
            // Only trigger if mostly horizontal
            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 10) { // lower threshold for smoother start
              seeking = true;
              // 1/2 screen = 60s seek, scale linearly, less volatile
              const width = playerContainer.offsetWidth;
              let seekSec = Math.round((dx / (width / 2)) * 60); // less sensitive
              // Clamp to [-300, 300]
              seekSec = Math.max(-300, Math.min(300, seekSec));
              // Only show overlay if abs(seekSec) >= 1
              if (Math.abs(seekSec) >= 1 && seekSec !== lastSeek) {
                showSeekOverlay(seekSec);
                lastSeek = seekSec;
              } else if (Math.abs(seekSec) < 1) {
                hideSeekOverlay();
                lastSeek = 0;
              }
              e.preventDefault();
            }
          }
        }, { passive: false });
        playerContainer.addEventListener('touchend', function(e) {
          if (seeking && Math.abs(lastSeek) >= 1) {
            video.currentTime = Math.max(0, Math.min(video.duration || 0, video.currentTime + lastSeek));
            showSeekOverlay(lastSeek, true);
            setTimeout(hideSeekOverlay, 700);
          } else {
            hideSeekOverlay();
          }
          seeking = false;
          lastSeek = 0;
        });
        // --- Double-tap to seek ---
        playerContainer.addEventListener('touchend', function(e) {
          if (e.changedTouches.length === 1 && !seeking) {
            const now = Date.now();
            const x = e.changedTouches[0].clientX;
            if (now - lastTap < 350 && Math.abs(x - tapX) < 60) {
              // Double tap detected
              const rect = playerContainer.getBoundingClientRect();
              const isLeft = x < rect.left + rect.width / 2;
              const seekSec = isLeft ? -10 : 10;
              video.currentTime = Math.max(0, Math.min(video.duration || 0, video.currentTime + seekSec));
              showSeekOverlay(seekSec, true);
              setTimeout(hideSeekOverlay, 700);
              lastTap = 0;
              tapX = 0;
            } else {
              lastTap = now;
              tapX = x;
            }
          }
        });
        // --- Overlay helpers ---
        function showSeekOverlay(secs, commit) {
          seekOverlay.textContent = (secs > 0 ? '+' : '') + secs + 's';
          seekOverlay.style.opacity = '1';
          if (commit) {
            seekOverlay.style.background = 'rgba(0,153,255,0.85)';
          } else {
            seekOverlay.style.background = 'rgba(0,0,0,0.7)';
          }
          clearTimeout(seekTimeout);
          if (commit) {
            seekTimeout = setTimeout(hideSeekOverlay, 700);
          }
        }
        function hideSeekOverlay() {
          seekOverlay.style.opacity = '0';
        }
      }
    </script>
  </body>
</html>
